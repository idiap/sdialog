"""
orchestrators: Dialogue Orchestration Utilities for sdialog

This module provides base and concrete classes for orchestrating agent behavior during synthetic dialogue generation.
Orchestrators can inject instructions, control agent responses, and manage dialogue flow for more complex scenarios.
"""
# SPDX-FileCopyrightText: Copyright Â© 2025 Idiap Research Institute <contact@idiap.ch>
# SPDX-FileContributor: Sergio Burdisso <sergio.burdisso@idiap.ch>
# SPDX-License-Identifier: MIT
import json
import random
import inspect
import numpy as np

from time import time
from abc import ABC, abstractmethod
from typing import List, Union, Dict
from sentence_transformers import SentenceTransformer
from langchain_core.messages import SystemMessage, AIMessage

from . import Turn, Event, Instruction
from .util import make_serializable
# from .agents import Agent  # Circular import error


class BaseOrchestrator(ABC):
    """
    Base class for orchestrators that control or influence Agent behavior during dialogue generation.

    Responsibilities:
      * Observe dialogue (agent memory) and produce turn-level instructions.
      * Optionally emit events describing guidance injected.
      * Support persistence across turns when marked persistent.

    :ivar _target: Target agent instance this orchestrator controls.
    :vartype _target: Agent
    :ivar _event_label: Optional explicit label used for emitted events.
    :vartype _event_label: str
    :ivar _persistent: Whether the orchestrator remains active across turns until removed/reset.
    :vartype _persistent: bool
    """

    _target = None
    _event_label = None
    _persistent = False

    def __init__(self, target_agent=None, persistent: bool = None, event_label: str = None):
        """
        Initialize the orchestrator.

        :param target_agent: Agent instance to orchestrate (can be set later).
        :type target_agent: Agent
        :param persistent: Whether produced instructions should persist each turn automatically.
        :type persistent: bool
        :param event_label: Optional label to tag generated events; defaults to class name.
        :type event_label: str
        """
        self._target = target_agent
        self._persistent = persistent
        self._event_label = event_label

    def __call__(self):
        """
        Produce an instruction for the target agent given current dialog state.

        Uses the agent memory to reconstruct a simplified dialog and calls instruct().

        :return: Instruction object/string or None if no instruction is produced.
        :rtype: Union[str, Instruction, None]
        """
        dialog = self.__get_current_dialog()
        return self.instruct(dialog, dialog[-1].text
                             if dialog and dialog[-1].speaker != self._target.get_name()
                             else "")

    def __str__(self) -> str:
        """
        String representation including constructor arguments.

        :return: Human-readable signature-like string.
        :rtype: str
        """
        data = self.json()
        attrs = " ".join(f"{key}={value}" for key, value in data["args"].items())
        return f"{data['name']}({attrs})"

    def __get_current_dialog(self) -> List[Turn]:
        """
        Reconstruct current dialog from agent memory (excluding system messages).

        :return: List of reconstructed turns.
        :rtype: List[Turn]
        """
        return [Turn(speaker=self._target.get_name() if type(message) is AIMessage else None, text=message.content)
                for message in self._target.memory if type(message) is not SystemMessage]

    def _set_target_agent(self, agent):  # agent: Agent):
        """
        Assign the target agent (late binding).

        :param agent: Agent instance to attach.
        :type agent: Agent
        """
        self._target = agent

    def json(self, string: bool = False, indent: int = None):
        """
        Serialize orchestrator configuration.

        :param string: If True returns JSON string; otherwise a dict.
        :type string: bool
        :param indent: Indentation for pretty JSON output (only if string=True).
        :type indent: int
        :return: Serialized configuration.
        :rtype: Union[str, dict]
        """
        sig = inspect.signature(self.__init__)
        data = {"name": type(self).__name__,
                "args": {key: self.__dict__[key] for key in sig.parameters
                         if key in self.__dict__ and self.__dict__[key] is not None}}
        make_serializable(data["args"])
        return json.dumps(data, indent=indent) if string else data

    def get_event_label(self) -> str:
        """
        Get the label used for events generated by this orchestrator.

        :return: Event label.
        :rtype: str
        """
        return self._event_label if self._event_label else type(self).__name__

    def get_target_agent(self):
        """
        Get the currently assigned target agent.

        :return: Agent instance or None.
        :rtype: Agent
        """
        return self._target

    def is_persistent(self):
        """
        Whether this orchestrator is persistent.

        :return: True if persistent.
        :rtype: bool
        """
        return self._persistent

    def set_persistent(self, value: bool):
        """
        Set persistence flag.

        :param value: New persistence state.
        :type value: bool
        """
        self._persistent = value

    def agent_response_lookahead(self):
        """
        Retrieve the agent's lookahead response (preview of next response if available).

        :return: Lookahead response string.
        :rtype: str
        """
        return self._target.response_lookahead()

    @abstractmethod
    def instruct(self, dialog: List[Turn], utterance: str) -> str:
        """
        Produce an instruction given the current dialog and (optionally) the last user utterance.

        :param dialog: Current reconstructed dialog (list of turns).
        :type dialog: List[Turn]
        :param utterance: Last opposite-party utterance (may be empty string).
        :type utterance: str
        :return: Instruction text, Instruction object, or None if no action needed.
        :rtype: Union[str, Instruction, None]
        """
        pass

    def reset(self):
        """
        Reset any internal state (overridden in stateful orchestrators).

        :return: None
        :rtype: None
        """
        pass


class BasePersistentOrchestrator(BaseOrchestrator):
    """
    Persistent orchestrator base class.

    Automatically sets persistence to True; intended for orchestrators that maintain state
    across the whole dialogue unless explicitly removed.
    """
    _persistent = True

    @abstractmethod
    def instruct(self, dialog: List[Turn], utterance: str) -> str:
        """
        See BaseOrchestrator.instruct; persistent variant.

        :param dialog: Current dialog state.
        :type dialog: List[Turn]
        :param utterance: Last opposite-party utterance.
        :type utterance: str
        :return: Instruction text/object or None.
        :rtype: Union[str, Instruction, None]
        """
        pass

    def reset(self):
        """
        Reset internal persistent state (override as needed).

        :return: None
        :rtype: None
        """
        pass


class SimpleReflexOrchestrator(BaseOrchestrator):
    """
    Simple reflex orchestrator that provides fixed instructions when a condition matches.
    """

    def __init__(self, condition: callable, instruction: str, persistent: bool = False, event_label: str = None):
        """
        Initialize SimpleReflexOrchestrator.

        :param condition: Predicate function receiving the last utterance; returns True to trigger.
        :type condition: callable
        :param instruction: Instruction text to return when condition is satisfied.
        :type instruction: str
        :param persistent: Whether orchestrator persists across turns.
        :type persistent: bool
        :param event_label: Optional event label override.
        :type event_label: str
        """
        super().__init__(persistent=persistent, event_label=event_label)
        self.condition = condition
        self.instruction = instruction

    def instruct(self, dialog: List[Turn], utterance: str) -> str:
        """
        Return the configured instruction if condition holds.

        :param dialog: Current dialog (unused except for extensibility).
        :type dialog: List[Turn]
        :param utterance: Last opposite-party utterance.
        :type utterance: str
        :return: Instruction text or None.
        :rtype: Union[str, None]
        """
        if self.condition(utterance):
            return self.instruction


class LengthOrchestrator(BaseOrchestrator):
    """
    Orchestrator that encourages continuation or termination based on current number of turns.
    """

    def __init__(self, min: int = None, max: int = None, persistent: bool = False, event_label: str = None):
        """
        Initialize LengthOrchestrator.

        :param min: Minimum turns before allowing termination (encourages continuation if not reached).
        :type min: int
        :param max: Maximum turns threshold after which termination is enforced.
        :type max: int
        :param persistent: Whether orchestrator persists.
        :type persistent: bool
        :param event_label: Optional event label.
        :type event_label: str
        """
        super().__init__(persistent=persistent, event_label=event_label)
        self.max = max
        self.min = min

    def instruct(self, dialog: List[Turn], utterance: str) -> str:
        """
        Provide an instruction to continue or finish based on dialog length.

        :param dialog: Current dialog state.
        :type dialog: List[Turn]
        :param utterance: Last opposite-party utterance.
        :type utterance: str
        :return: Instruction text or None.
        :rtype: Union[str, None]
        """
        if self.min is not None and len(dialog) < self.min and len(dialog) > 1:
            return "Make sure you DO NOT finish the conversation, keep it going!"
        elif self.max and len(dialog) >= self.max - 1:  # + answer
            return "Now FINISH the conversation AS SOON AS possible, if possible, RIGHT NOW!"


class ChangeMindOrchestrator(BaseOrchestrator):
    """
    Orchestrator that probabilistically injects a 'change your mind' instruction a limited number of times.
    """

    def __init__(self, probability: float = 0.3,
                 reasons: Union[str, List[str]] = None,
                 max_times: int = 1,
                 persistent: bool = False,
                 event_label: str = None):
        """
        Initialize ChangeMindOrchestrator.

        :param probability: Probability (0-1) each eligible turn to trigger a mind-change.
        :type probability: float
        :param reasons: Optional reason(s) appended; single string or list.
        :type reasons: Union[str, List[str]]
        :param max_times: Maximum number of injections allowed.
        :type max_times: int
        :param persistent: Persistence flag.
        :type persistent: bool
        :param event_label: Event label override.
        :type event_label: str
        """
        super().__init__(persistent=persistent, event_label=event_label)
        self.probability = probability
        self.reasons = [reasons] if type(reasons) is str else reasons
        self.max_times = max_times
        self.times = 0

    def reset(self):
        """
        Reset internal counter of times triggered.

        :return: None
        :rtype: None
        """
        self.times = 0

    def instruct(self, dialog: List[Turn], utterance: str) -> str:
        """
        Possibly return a mind-change instruction based on probability and remaining allowance.

        :param dialog: Current dialog state.
        :type dialog: List[Turn]
        :param utterance: Last opposite-party utterance.
        :type utterance: str
        :return: Instruction text or None.
        :rtype: Union[str, None]
        """
        if self.max_times and self.times >= self.max_times:
            return

        if random.random() <= self.probability:
            self.times += 1
            instruction = "Change your mind completely, in your next utterance, suggest something completely different!"
            if self.reasons:
                instruction += f" **Reason:** {random.choice(self.reasons)}."
            return instruction


class SimpleResponseOrchestrator(BaseOrchestrator):
    """
    Orchestrator that suggests next responses based on semantic similarity against a response set (or action graph).
    """

    def __init__(self,
                 responses: List[Union[str, Dict[str, str]]],
                 graph: Dict[str, str] = None,
                 #  sbert_model: str = "sentence-transformers/LaBSE",
                 sbert_model: str = "sergioburdisso/dialog2flow-joint-bert-base",
                 top_k: int = 5):
        """
        Initialize SimpleResponseOrchestrator.

        :param responses: List (plain strings) or dict (action -> response) entries.
        :type responses: List[Union[str, Dict[str, str]]]
        :param graph: Optional action transition graph (current_action -> next_action).
        :type graph: Dict[str, str]
        :param sbert_model: SentenceTransformer model name.
        :type sbert_model: str
        :param top_k: Number of top similar responses/actions to surface.
        :type top_k: int
        """
        self.sent_encoder = SentenceTransformer(sbert_model)
        self.responses = responses
        self.top_k = top_k

        if type(responses) is dict:
            self.resp_utts = np.array([resp for resp in responses.values()])
            self.resp_acts = np.array([act for act in responses.keys()])
            self.graph = graph
        else:
            self.resp_utts = np.array(responses)
            self.resp_acts = None
            self.graph = None

        self.resp_utt_embs = self.sent_encoder.encode(self.resp_utts)

    def instruct(self, dialog: List[Turn], utterance: str) -> str:
        """
        Build an Instruction containing candidate responses (and events for traceability).

        :param dialog: Current dialog.
        :type dialog: List[Turn]
        :param utterance: Last opposite-party utterance (unused directly; similarity uses lookahead / last turn).
        :type utterance: str
        :return: Instruction object with suggestion list.
        :rtype: Instruction
        """
        agent = self.get_target_agent()

        agent_last_turn = None
        if self.graph and dialog:
            for turn in dialog[::-1]:
                if turn.speaker == agent.get_name():
                    agent_last_turn = turn.text
                    break

        response = agent_last_turn if agent_last_turn else agent.response_lookahead()

        events = [Event(agent=agent.get_name(),
                        action="request_suggestions",
                        actionLabel=self.get_event_label(),
                        text=f'Previous response: "{response}"'
                             if agent_last_turn
                             else f'Lookahead response: "{response}"',
                        timestamp=int(time()))]

        sims = self.sent_encoder.similarity(self.sent_encoder.encode(response), self.resp_utt_embs)[0]
        top_k_ixs = sims.argsort(descending=True)[:self.top_k]

        if self.resp_acts is None:
            instruction = ("If applicable, try to pick your next response from the following list: "
                           + "; ".join(f'({ix + 1}) {resp}' for ix, resp in enumerate(self.resp_utts[top_k_ixs])))
        else:
            next_actions = self.resp_acts[top_k_ixs].tolist()
            events.append(Event(agent=agent.get_name(),
                                action="request_suggestions",
                                actionLabel=self.get_event_label(),
                                text="Actions for the response: " + ", ".join(action for action in next_actions),
                                timestamp=int(time())))
            if agent_last_turn:
                next_actions = [self.graph[action] if action in self.graph else action
                                for action in next_actions]
                events.append(Event(agent=agent.get_name(),
                                    action="request_suggestions",
                                    actionLabel=self.get_event_label(),
                                    text="Graph next actions: " + ", ".join(action for action in next_actions),
                                    timestamp=int(time())))

            # TODO: remove repeated actions! (make it a set()?)
            next_actions = [action for action in next_actions if action in self.responses]
            instruction = (
                "If applicable, pick your next response from the following action list in order of importance: "
                + "; ".join(f'({ix + 1}) Action: {action}. Response: "{self.responses[action]}"'
                            for ix, action in enumerate(next_actions))
            )

        return Instruction(text=instruction, events=events)


class InstructionListOrchestrator(BaseOrchestrator):
    """
    Orchestrator that dispenses predefined instructions sequentially or by turn index mapping.
    """

    def __init__(self,
                 instructions: List[Union[str, Dict[int, str]]],
                 persistent: bool = False):
        """
        Initialize InstructionListOrchestrator.

        :param instructions: Either list (indexed per agent turn) or dict mapping agent turn index -> instruction.
        :type instructions: List[Union[str, Dict[int, str]]]
        :param persistent: Persistence flag.
        :type persistent: bool
        """
        super().__init__(persistent=persistent)
        self.instructions = instructions

    def instruct(self, dialog: List[Turn], utterance: str) -> str:
        """
        Return the next scheduled instruction if available.

        :param dialog: Current dialog.
        :type dialog: List[Turn]
        :param utterance: Last opposite-party utterance.
        :type utterance: str
        :return: Instruction text or None.
        :rtype: Union[str, None]
        """
        agent = self.get_target_agent()

        if dialog:
            current_user_len = len([t for t in dialog if t.speaker == agent.get_name()])
        else:
            current_user_len = 0

        if (type(self.instructions) is dict and current_user_len in self.instructions) or \
           (type(self.instructions) is list and current_user_len < len(self.instructions)):
            return self.instructions[current_user_len]
